export const topics = [
    "Sin Curve and Unit Circle",
    "Integral Area Under Curve",
    "Basic Neural Network",
    "Network Effects",
    "Complex Numbers",
    "Elliptic Curves",
    "Basic Trigonometry",
    "Probability Distributions",
    "Pythagorean Theorem",
    "Vector Matrices",
    "Word Embeddings",
    "Bubble Sort",
    "Sierpinski Triangle Fractal"
]

export const codes = [
    `def construct(self):\n        # Create the coordinate system\n        axes = Axes(\n            x_range=[0, 4*PI, PI],\n            y_range=[-1.5, 1.5, 0.5],\n            x_length=12,\n            y_length=6,\n            axis_config={\"color\": BLUE},\n            x_axis_config={\"numbers_to_include\": []},  # Remove default numbers\n            y_axis_config={\"numbers_to_include\": [-1, 1]},\n            tips=False\n        )\n        axes_labels = axes.get_axis_labels(x_label=\"x\", y_label=\"y\")\n\n        # Create the unit circle\n        circle = Circle(radius=1, color=WHITE)\n        circle.move_to(axes.c2p(0, 0))\n\n        # Create the angle\n        angle = ValueTracker(0)\n        line = always_redraw(lambda: Line(circle.get_center(), circle.point_at_angle(angle.get_value()), color=YELLOW))\n        \n        # Create the sine curve\n        sine_curve = always_redraw(\n            lambda: axes.plot(\n                lambda x: np.sin(x),\n                x_range=[0, angle.get_value()],\n                color=RED\n            )\n        )\n\n        # Create the dot on the circle and its projection\n        moving_dot = always_redraw(lambda: Dot(circle.point_at_angle(angle.get_value()), color=RED))\n        h_line = always_redraw(lambda: DashedLine(\n            moving_dot.get_center(),\n            axes.c2p(angle.get_value(), np.sin(angle.get_value())),\n            color=GRAY\n        ))\n        v_line = always_redraw(lambda: DashedLine(\n            axes.c2p(angle.get_value(), 0),\n            axes.c2p(angle.get_value(), np.sin(angle.get_value())),\n            color=GRAY\n        ))\n        sine_dot = always_redraw(lambda: Dot(\n            axes.c2p(angle.get_value(), np.sin(angle.get_value())),\n            color=RED\n        ))\n\n        # Labels\n        sine_label = MathTex(r\"\\sin(x)\").next_to(axes, UP).set_color(RED)\n        pi_labels = VGroup(*[\n            MathTex(f\"{i}\\pi\").next_to(axes.c2p(i*PI, 0), DOWN)\n            for i in range(1, 5)\n        ])\n\n        # Animations\n        self.play(Create(axes), Write(axes_labels))\n        self.play(Create(circle))\n        self.play(Create(line), Create(moving_dot))\n        self.play(Write(sine_label), Create(h_line), Create(v_line), Create(sine_dot))\n        self.play(Create(sine_curve))\n        self.play(Write(pi_labels))\n\n        # Animate the sine curve\n        self.play(angle.animate.set_value(4*PI), run_time=12, rate_func=linear)\n        self.wait()\n\n        # Highlight key points\n        highlight_points = [\n            (0, \"y = 0\"),\n            (PI/2, \"y = 1\"),\n            (PI, \"y = 0\"),\n            (3*PI/2, \"y = -1\"),\n        \n        ]\n\n        for x, label_text in highlight_points:\n            point = axes.c2p(x, np.sin(x))\n            dot = Dot(point, color=YELLOW)\n            label = Text(label_text, font_size=24).next_to(dot, UP)\n            self.play(Create(dot), Write(label))\n            self.wait(0.5)\n            self.play(FadeOut(dot), FadeOut(label))\n\n        self.wait(2)`, `def construct(self):\n        # Title\n        title = Text(\"Integral: Area Under the Curve\", font_size=42)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Create axes\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 3],\n            axis_config={\"color\": BLUE},\n            x_length=6,\n            y_length=4\n        ).add_coordinates()\n        axes_labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Create graph\n        def func(x):\n            return 0.1 * (x - 1) * (x - 3) * (x - 4) + 2\n\n        graph = axes.plot(func, color=WHITE)\n        graph_label = MathTex(\"f(x)\").next_to(graph.point_from_proportion(0.8), UP)\n\n        # Display axes and graph\n        self.play(Create(axes), Create(axes_labels))\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Integral formula\n        integral = MathTex(r\"\\int_a^b f(x) dx\")\n        integral_text = Text(\"Area under the curve\", font_size=24)\n        integral_group = VGroup(integral, integral_text).arrange(DOWN).to_edge(RIGHT)\n        self.play(Write(integral_group))\n        self.wait(1)\n\n        # Show Riemann sum\n        rectangles = axes.get_riemann_rectangles(\n            graph,\n            x_range=[1, 4],\n            dx=0.5,\n            stroke_width=0.1,\n            stroke_color=WHITE\n        )\n        self.play(Create(rectangles))\n        self.wait(1)\n\n        # Refine Riemann sum\n        for dx in [0.25, 0.1]:\n            new_rectangles = axes.get_riemann_rectangles(\n                graph,\n                x_range=[1, 4],\n                dx=dx,\n                stroke_width=0.1,\n                stroke_color=WHITE\n            )\n            self.play(Transform(rectangles, new_rectangles))\n            self.wait(1)\n\n        # Show area\n        area = axes.get_area(graph, x_range=[1, 4], color=YELLOW, opacity=0.3)\n        self.play(FadeOut(rectangles), FadeIn(area))\n        self.wait(1)\n\n        # Highlight bounds\n        x_1 = axes.get_vertical_line(axes.c2p(1, 0), color=GREEN)\n        x_4 = axes.get_vertical_line(axes.c2p(4, 0), color=RED)\n        bound_labels = VGroup(\n            MathTex(\"a\").next_to(x_1, DOWN),\n            MathTex(\"b\").next_to(x_4, DOWN)\n        )\n        self.play(Create(x_1), Create(x_4), Write(bound_labels))\n        self.wait(1)\n\n        # Final formula\n        final_integral = MathTex(r\"\\int_1^4 f(x) dx = \\text{Area}\")\n        final_integral.next_to(area, DOWN, buff=0.5)\n        self.play(Write(final_integral))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\n            \"The definite integral represents\\nthe area under the curve\\nbetween two points\",\n            font_size=32,\n            t2c={\"area\": YELLOW, \"two points\": GREEN}\n        ).next_to(final_integral, DOWN, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(2)`
    
    
    ,`def construct(self):\n        # Title\n        title = Text(\"Basic Neural Network\", font_size=42)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Create layers\n        input_layer = VGroup(*[Circle(radius=0.2, color=BLUE) for _ in range(4)]).arrange(DOWN, buff=0.5)\n        hidden_layer = VGroup(*[Circle(radius=0.2, color=GREEN) for _ in range(5)]).arrange(DOWN, buff=0.5)\n        output_layer = VGroup(*[Circle(radius=0.2, color=RED) for _ in range(3)]).arrange(DOWN, buff=0.5)\n\n        # Arrange layers\n        layers = VGroup(input_layer, hidden_layer, output_layer).arrange(RIGHT, buff=2)\n        self.play(Create(layers))\n        self.wait(1)\n\n        # Add layer labels\n        labels = VGroup(\n            Text(\"Input Layer\").next_to(input_layer, DOWN),\n            Text(\"Hidden Layer\").next_to(hidden_layer, DOWN),\n            Text(\"Output Layer\").next_to(output_layer, DOWN)\n        )\n        self.play(Write(labels))\n        self.wait(1)\n\n        # Create connections\n        connections = VGroup()\n        for i, layer1 in enumerate(layers[:-1]):\n            layer2 = layers[i+1]\n            for neuron1 in layer1:\n                for neuron2 in layer2:\n                    connection = Line(neuron1.get_center(), neuron2.get_center(), stroke_opacity=0.3)\n                    connections.add(connection)\n\n        self.play(Create(connections), run_time=2)\n        self.wait(1)\n\n        # Highlight data flow\n        def highlight_path():\n            path = VGroup()\n            for i in range(len(layers) - 1):\n                start_neuron = random.choice(layers[i])\n                end_neuron = random.choice(layers[i+1])\n                path.add(Line(start_neuron.get_center(), end_neuron.get_center(), stroke_width=4, color=YELLOW))\n            return path\n\n        for _ in range(3):  # Show 3 random paths\n            path = highlight_path()\n            self.play(Create(path), run_time=0.5)\n            self.wait(0.5)\n            self.play(FadeOut(path), run_time=0.5)\n\n        # Add explanation\n        explanation = VGroup(\n            Text(\"• Each circle represents a neuron\", font_size=24),\n            Text(\"• Lines represent connections between neurons\", font_size=24),\n            Text(\"• Information flows from input to output\", font_size=24),\n            Text(\"• The hidden layer allows for complex pattern recognition\", font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT).next_to(layers, DOWN, buff=0.5)\n\n        self.play(Write(explanation), run_time=2)\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\n            \"Neural networks can learn to recognize patterns\\nand make decisions based on input data\",\n            font_size=32\n        ).next_to(explanation, DOWN, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(2)`,`def construct(self):\n        # Title\n        title = Text(\"Network Effects\", font_size=42)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Explanation text\n        explanation = Text(\n            \"The value of a network increases as more users join\",\n            font_size=24\n        ).next_to(title, DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Create initial network\n        def create_network(num_nodes):\n            nodes = VGroup(*[Dot(radius=0.1, color=BLUE) for _ in range(num_nodes)])\n            nodes.arrange_in_grid(rows=int(num_nodes**0.5), buff=1)\n            return nodes\n\n        initial_nodes = create_network(9)\n        self.play(Create(initial_nodes))\n        self.wait(1)\n\n        # Add connections\n        def add_connections(nodes, probability=0.3):\n            connections = VGroup()\n            for i, node1 in enumerate(nodes):\n                for j, node2 in enumerate(nodes[i+1:], start=i+1):\n                    if random.random() < probability:\n                        line = Line(node1.get_center(), node2.get_center(), stroke_opacity=0.5)\n                        connections.add(line)\n            return connections\n\n        initial_connections = add_connections(initial_nodes)\n        self.play(Create(initial_connections))\n        self.wait(1)\n\n        # Show value\n        value_text = Text(\"Network Value\", font_size=36).to_edge(LEFT)\n        value = DecimalNumber(\n            9,  # Initial value\n            num_decimal_places=0,\n            font_size=36\n        ).next_to(value_text, RIGHT)\n        self.play(Write(value_text), Write(value))\n        self.wait(1)\n\n        # Function to update network\n        def update_network(num_new_nodes):\n            new_nodes = create_network(num_new_nodes)\n            new_nodes.move_to(initial_nodes.get_center())\n            scale_factor = initial_nodes.width / new_nodes.width\n            new_nodes.scale(scale_factor)\n            \n            all_nodes = VGroup(*initial_nodes, *new_nodes)\n            new_connections = add_connections(all_nodes, probability=0.1)\n            \n            new_value = len(all_nodes) ** 2  # Metcalfe's Law\n            \n            return new_nodes, new_connections, new_value\n\n        # Add users and show increased value\n        for _ in range(3):\n            new_nodes, new_connections, new_value = update_network(9)\n            \n            self.play(\n                Create(new_nodes),\n                Create(new_connections),\n                ChangeDecimalToValue(value, new_value)\n            )\n            self.wait(1)\n            \n            initial_nodes.add(*new_nodes)\n            initial_connections.add(*new_connections)\n\n        # Highlight network effect\n        self.play(Indicate(initial_nodes, color=YELLOW), Indicate(initial_connections, color=YELLOW))\n        self.wait(1)\n\n        # Metcalfe's Law\n        metcalfe = Text(\"Metcalfe's Law: Value ∝ n²\", font_size=36).to_edge(DOWN)\n        self.play(Write(metcalfe))\n        self.wait(1)\n\n        # Examples\n        examples = VGroup(\n            Text(\"• Social networks\", font_size=24),\n            Text(\"• Communication platforms\", font_size=24),\n            Text(\"• Operating systems\", font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT).next_to(metcalfe, UP)\n        self.play(Write(examples))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\n            \"Network effects create a positive feedback loop,\\ndriving rapid growth and market dominance\",\n            font_size=32\n        ).next_to(examples, UP)\n        self.play(Write(conclusion))\n        self.wait(2)`,`def construct(self):\n        # Title\n        title = Text(\"Complex Numbers\", font_size=48)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Basic definition\n        definition = MathTex(\"z = a + bi\", \", where \", \"i^2 = -1\")\n        self.play(Write(definition))\n        self.wait(1)\n        self.play(definition.animate.to_edge(UP).shift(DOWN))\n\n        # Create complex plane\n        plane = ComplexPlane().scale(2)\n        self.play(Create(plane))\n        self.wait(1)\n\n        # Show a complex number\n        z = 3 + 2j\n        dot_z = Dot(plane.n2p(z), color=RED)\n        label_z = MathTex(\"z = 3 + 2i\").next_to(dot_z, UR, buff=0.1)\n        arrow_z = Arrow(plane.n2p(0), plane.n2p(z), buff=0, color=RED)\n        self.play(Create(dot_z), Write(label_z), Create(arrow_z))\n        self.wait(1)\n\n        # Show real and imaginary parts\n        real_line = Line(plane.n2p(0), plane.n2p(z.real), color=GREEN)\n        imag_line = Line(plane.n2p(z.real), plane.n2p(z), color=BLUE)\n        real_label = MathTex(\"Re(z) = 3\").next_to(real_line, DOWN, buff=0.1)\n        imag_label = MathTex(\"Im(z) = 2\").next_to(imag_line, RIGHT, buff=0.1)\n        self.play(Create(real_line), Create(imag_line), Write(real_label), Write(imag_label))\n        self.wait(1)\n\n        # Polar form\n        angle = np.angle(z)\n        radius = abs(z)\n        arc = Arc(radius=0.5, angle=angle, color=YELLOW)\n        radius_line = Line(plane.n2p(0), plane.n2p(z), color=YELLOW)\n        angle_label = MathTex(r\"\\theta\").next_to(arc, RIGHT, buff=0.1)\n        radius_label = MathTex(r\"|z| = \\sqrt{a^2 + b^2}\").next_to(radius_line, UR, buff=0.1)\n        self.play(Create(arc), Create(radius_line), Write(angle_label), Write(radius_label))\n        self.wait(1)\n\n        # Polar form equation\n        polar_form = MathTex(\"z = |z|(\\\\cos\\\\theta + i\\\\sin\\\\theta) = |z|e^{i\\\\theta}\")\n        polar_form.to_edge(DOWN)\n        self.play(Write(polar_form))\n        self.wait(1)\n\n        # Addition\n        w = 1 - 1j\n        dot_w = Dot(plane.n2p(w), color=BLUE)\n        label_w = MathTex(\"w = 1 - i\").next_to(dot_w, UL, buff=0.1)\n        arrow_w = Arrow(plane.n2p(0), plane.n2p(w), buff=0, color=BLUE)\n        self.play(Create(dot_w), Write(label_w), Create(arrow_w))\n        self.wait(1)\n\n        sum_z_w = z + w\n        dot_sum = Dot(plane.n2p(sum_z_w), color=PURPLE)\n        label_sum = MathTex(\"z + w\").next_to(dot_sum, UR, buff=0.1)\n        arrow_sum = Arrow(plane.n2p(0), plane.n2p(sum_z_w), buff=0, color=PURPLE)\n        self.play(Create(dot_sum), Write(label_sum), Create(arrow_sum))\n        self.wait(1)\n\n        # Multiplication\n        product = z * w\n        dot_product = Dot(plane.n2p(product), color=ORANGE)\n        label_product = MathTex(\"z \\\\times w\").next_to(dot_product, UR, buff=0.1)\n        arrow_product = Arrow(plane.n2p(0), plane.n2p(product), buff=0, color=ORANGE)\n        self.play(Create(dot_product), Write(label_product), Create(arrow_product))\n        self.wait(1)\n\n        # Explanation of multiplication\n        mult_explanation = Text(\"Multiplication: rotate and scale\", font_size=24).to_edge(DOWN)\n        self.play(Write(mult_explanation))\n        self.wait(1)\n\n        # Applications\n        applications = VGroup(\n            Text(\"Applications:\", font_size=28),\n            Text(\"• Electrical Engineering\", font_size=24),\n            Text(\"• Quantum Mechanics\", font_size=24),\n            Text(\"• Computer Graphics\", font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT).to_edge(RIGHT)\n        self.play(Write(applications))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\n            \"Complex numbers extend real numbers\\n\"\n            \"and have powerful geometric interpretations.\",\n            font_size=24\n        ).next_to(applications, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)`,`def construct(self):\n            # Title\n            title = Text(\"Elliptic Curves\", font_size=48).to_edge(UP)\n            self.play(Write(title))\n\n            # Create axes\n            axes = Axes(\n                x_range=[-3, 3, 1],\n                y_range=[-3, 3, 1],\n                axis_config={\"color\": BLUE},\n                x_length=6,\n                y_length=6\n            ).add_coordinates()\n            self.play(Create(axes))\n\n            # Define and plot elliptic curve\n            a, b = -1, 1  # Example parameters\n            curve = VGroup(\n                ParametricFunction(\n                    lambda t: axes.c2p(t, np.sqrt(max(0, t**3 - t + 1))),\n                    t_range=[-1.5, 3],\n                    color=RED,\n                ),\n                ParametricFunction(\n                    lambda t: axes.c2p(t, -np.sqrt(max(0, t**3 - t + 1))),\n                    t_range=[-1.5, 3],\n                    color=RED,\n                )\n            )\n            self.play(Create(curve))\n\n            # Show equation\n            equation = MathTex(\"y^2 = x^3 + ax + b\").next_to(axes, UP).shift(LEFT * 2)\n            params = MathTex(\"a = -1, b = 1\").next_to(equation, DOWN)\n            self.play(Write(equation), Write(params))\n\n            # Demonstrate point addition\n            P = Dot(axes.c2p(-1, 1), color=GREEN)\n            Q = Dot(axes.c2p(0, 1), color=BLUE)\n            P_label = Text(\"P\", font_size=24).next_to(P, UP)\n            Q_label = Text(\"Q\", font_size=24).next_to(Q, UP)\n            self.play(Create(P), Create(Q), Write(P_label), Write(Q_label))\n\n            # Line through P and Q\n            line = Line(P.get_center(), Q.get_center())\n            line.scale(5)  # Scale the line instead of using scale_about_point\n            self.play(Create(line))\n\n            # Find third intersection point\n            R = Dot(axes.c2p(2, -3), color=YELLOW)\n            R_label = Text(\"R\", font_size=24).next_to(R, DOWN)\n            self.play(Create(R), Write(R_label))\n\n            # Reflect R across x-axis to get P+Q\n            PplusQ = Dot(axes.c2p(2, 3), color=PURPLE)\n            PplusQ_label = Text(\"P+Q\", font_size=24).next_to(PplusQ, UP)\n            dashed_line = DashedLine(R.get_center(), PplusQ.get_center())\n            self.play(Create(dashed_line), Create(PplusQ), Write(PplusQ_label))\n\n            # Explanation of point addition\n            addition_explanation = Text(\n                \"Point addition: P + Q = -(P * Q * curve)\",\n                font_size=24\n            ).to_edge(DOWN)\n            self.play(Write(addition_explanation))\n\n            # Applications\n            applications = VGroup(\n                Text(\"Applications:\", font_size=28),\n                Text(\"• Cryptography\", font_size=24),\n                Text(\"• Number Theory\", font_size=24)\n            ).arrange(DOWN, aligned_edge=LEFT).to_edge(RIGHT)\n            self.play(Write(applications))\n\n            # Conclusion\n            conclusion = Text(\n                \"Elliptic curves have a rich structure\\n\"\n                \"with important applications.\",\n                font_size=24\n            ).next_to(applications, DOWN)\n            self.play(Write(conclusion))\n            self.wait(2)`,`def construct(self):\n        # Title\n        title = Text(\"Basic Trigonometry\", font_size=48)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Create unit circle\n        circle = Circle(radius=2, color=BLUE)\n        self.play(Create(circle))\n        self.wait(1)\n\n        # Add axes\n        axes = Axes(\n            x_range=[-2.5, 2.5],\n            y_range=[-2.5, 2.5],\n            axis_config={\"color\": GRAY},\n            x_length=5,\n            y_length=5\n        )\n        self.play(Create(axes))\n        self.wait(1)\n\n        # Add labels\n        x_label = axes.get_x_axis_label(\"x\")\n        y_label = axes.get_y_axis_label(\"y\")\n        self.play(Write(x_label), Write(y_label))\n        self.wait(1)\n\n        # Create angle\n        angle = ValueTracker(0)\n        line = always_redraw(lambda: Line(ORIGIN, axes.c2p(np.cos(angle.get_value()), np.sin(angle.get_value())), color=YELLOW))\n        angle_arc = always_redraw(lambda: Arc(radius=0.5, angle=angle.get_value(), color=GREEN))\n        angle_label = always_redraw(lambda: MathTex(r\"\\theta\").next_to(angle_arc, RIGHT, buff=0.1))\n        \n        self.play(Create(line), Create(angle_arc), Write(angle_label))\n        self.wait(1)\n\n        # Show sine and cosine\n        sine_line = always_redraw(lambda: Line(\n            axes.c2p(np.cos(angle.get_value()), 0),\n            axes.c2p(np.cos(angle.get_value()), np.sin(angle.get_value())),\n            color=RED\n        ))\n        cosine_line = always_redraw(lambda: Line(\n            ORIGIN,\n            axes.c2p(np.cos(angle.get_value()), 0),\n            color=GREEN\n        ))\n        \n        sine_label = always_redraw(lambda: MathTex(r\"\\sin(\\theta)\").next_to(sine_line, RIGHT, buff=0.1))\n        cosine_label = always_redraw(lambda: MathTex(r\"\\cos(\\theta)\").next_to(cosine_line, DOWN, buff=0.1))\n        \n        self.play(Create(sine_line), Create(cosine_line), Write(sine_label), Write(cosine_label))\n        self.wait(1)\n\n        # Animate the angle\n        self.play(angle.animate.set_value(PI/2), run_time=2)\n        self.wait(1)\n        self.play(angle.animate.set_value(PI), run_time=2)\n        self.wait(1)\n        self.play(angle.animate.set_value(3*PI/2), run_time=2)\n        self.wait(1)\n        self.play(angle.animate.set_value(2*PI), run_time=2)\n        self.wait(1)\n\n        # Show right triangle\n        triangle = always_redraw(lambda: Polygon(\n            ORIGIN,\n            axes.c2p(np.cos(angle.get_value()), 0),\n            axes.c2p(np.cos(angle.get_value()), np.sin(angle.get_value())),\n            color=WHITE\n        ))\n        self.play(Create(triangle))\n        self.wait(1)\n\n        # Add formulas\n        formulas = VGroup(\n            MathTex(r\"\\sin(\\theta) = \\frac{\\text{opposite}}{\\text{hypotenuse}}\"),\n            MathTex(r\"\\cos(\\theta) = \\frac{\\text{adjacent}}{\\text{hypotenuse}}\"),\n            MathTex(r\"\\tan(\\theta) = \\frac{\\text{opposite}}{\\text{adjacent}} = \\frac{\\sin(\\theta)}{\\cos(\\theta)}\")\n        ).arrange(DOWN, aligned_edge=LEFT).to_edge(RIGHT)\n        self.play(Write(formulas))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\n            \"Trigonometric functions relate\\nangles to ratios of sides\\nin right triangles\",\n            font_size=24\n        ).next_to(formulas, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)`,`def construct(self):\n        title = Text(\"Probability Distributions\", font_size=48)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 0.5, 0.1],\n            axis_config={\"color\": BLUE},\n            x_length=10,\n            y_length=5\n        ).shift(DOWN)\n        \n        x_label = axes.get_x_axis_label(\"x\")\n        y_label = axes.get_y_axis_label(\"P(x)\")\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        self.wait(1)\n\n        def normal_pdf(x):\n            return stats.norm.pdf(x, loc=0, scale=1)\n\n        normal_graph = axes.plot(normal_pdf, color=RED)\n        normal_label = Text(\"Normal Distribution\", font_size=24, color=RED).next_to(normal_graph, UP)\n        \n        self.play(Create(normal_graph), Write(normal_label))\n        self.wait(1)\n\n        def uniform_pdf(x):\n            return stats.uniform.pdf(x, loc=-2, scale=4)\n\n        uniform_graph = axes.plot(uniform_pdf, color=GREEN)\n        uniform_label = Text(\"Uniform Distribution\", font_size=24, color=GREEN).next_to(uniform_graph, DOWN)\n        \n        self.play(Create(uniform_graph), Write(uniform_label))\n        self.wait(1)\n\n        def exponential_pdf(x):\n            return stats.expon.pdf(x, loc=0, scale=1)\n\n        exponential_graph = axes.plot(exponential_pdf, color=YELLOW)\n        exponential_label = Text(\"Exponential Distribution\", font_size=24, color=YELLOW).next_to(exponential_graph, RIGHT)\n        \n        self.play(Create(exponential_graph), Write(exponential_label))\n        self.wait(2)`,
    
    `def construct(self):\n        # Title\n        title = Text(\"Pythagorean Theorem\", font_size=48)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Create right triangle\n        triangle = Polygon(\n            ORIGIN, 4*RIGHT, 4*RIGHT + 3*UP,\n            color=WHITE, fill_opacity=0.2\n        ).move_to(ORIGIN)\n        self.play(Create(triangle))\n        self.wait(1)\n\n        # Label sides\n        labels = VGroup(\n            MathTex(\"a\").next_to(triangle.get_bottom(), DOWN),\n            MathTex(\"b\").next_to(triangle.get_right(), RIGHT),\n            MathTex(\"c\").next_to(triangle.get_top() + triangle.get_left(), UP+LEFT)\n        )\n        self.play(Write(labels))\n        self.wait(1)\n\n        # Show equation\n        equation = MathTex(\"a^2\", \"+\", \"b^2\", \"=\", \"c^2\")\n        equation.next_to(triangle, DOWN, buff=1)\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Create squares on each side\n        square_a = Square(side_length=3, color=RED, fill_opacity=0.5)\n        square_b = Square(side_length=4, color=GREEN, fill_opacity=0.5)\n        square_c = Square(side_length=5, color=BLUE, fill_opacity=0.5)\n\n        square_a.next_to(triangle, DOWN, buff=0.5)\n        square_b.next_to(triangle, RIGHT, buff=0.5)\n        square_c.move_to(triangle.get_center()).rotate(np.arctan(3/4))\n\n        self.play(\n            Create(square_a),\n            Create(square_b),\n            Create(square_c)\n        )\n        self.wait(1)\n\n        # Label areas\n        area_labels = VGroup(\n            MathTex(\"a^2\").move_to(square_a.get_center()),\n            MathTex(\"b^2\").move_to(square_b.get_center()),\n            MathTex(\"c^2\").move_to(square_c.get_center())\n        )\n        self.play(Write(area_labels))\n        self.wait(1)\n\n        # Highlight equation parts\n        for i, square in enumerate([square_a, square_b, square_c]):\n            self.play(\n                Indicate(square, color=YELLOW),\n                Indicate(equation[i*2], color=YELLOW)\n            )\n            self.wait(0.5)\n\n        # Remove shapes and center equation\n        self.play(\n            FadeOut(triangle),\n            FadeOut(labels),\n            FadeOut(square_a),\n            FadeOut(square_b),\n            FadeOut(square_c),\n            FadeOut(area_labels),\n            equation.animate.move_to(ORIGIN)\n        )\n        self.wait(1)\n\n        # Show numerical example\n        example = MathTex(\"3^2\", \"+\", \"4^2\", \"=\", \"5^2\")\n        example.next_to(equation, DOWN, buff=0.5)\n        self.play(Write(example))\n        self.wait(1)\n\n        # Evaluate\n        result = MathTex(\"9\", \"+\", \"16\", \"=\", \"25\")\n        result.next_to(example, DOWN, buff=0.5)\n        self.play(Write(result))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The sum of the squares of the two shorter sides\\nequals the square of the longest side\", \n                          font_size=36, t2c={\"squares\": YELLOW, \"longest side\": BLUE})\n        conclusion.next_to(result, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)`,

    `def construct(self):\n        # Title\n        title = Text(\"Vector Matrices and Transformations\", font_size=42)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Create a 2D coordinate system\n        axes = Axes(\n            x_range=[-5, 5],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        ).add_coordinates()\n        self.play(Create(axes))\n        self.wait(1)\n\n        # Define and show a vector\n        vector = Vector([3, 2], color=YELLOW)\n        vector_label = MathTex(r\"\\vec{v} = \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix}\").next_to(vector.get_end(), RIGHT)\n        self.play(GrowArrow(vector), Write(vector_label))\n        self.wait(1)\n\n        # Define a transformation matrix\n        matrix = MathTex(r\"A = \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}\")\n        matrix.to_edge(LEFT)\n        self.play(Write(matrix))\n        self.wait(1)\n\n        # Show matrix multiplication\n        multiplication = MathTex(r\"A\\vec{v} = \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix} = \\begin{bmatrix} -2 \\\\ 3 \\end{bmatrix}\")\n        multiplication.next_to(matrix, DOWN, buff=0.5)\n        self.play(Write(multiplication))\n        self.wait(1)\n\n        # Show the transformed vector\n        transformed_vector = Vector([-2, 3], color=RED)\n        transformed_label = MathTex(r\"A\\vec{v}\").next_to(transformed_vector.get_end(), RIGHT)\n        self.play(GrowArrow(transformed_vector), Write(transformed_label))\n        self.wait(1)\n\n        # Animate the transformation\n        def matrix_transform(point):\n            x, y, z = point\n            return np.array([\n                -y,\n                x,\n                0\n            ])\n        \n        self.play(\n            vector.animate.apply_function(matrix_transform),\n            vector_label.animate.next_to(transformed_vector.get_end(), RIGHT),\n            run_time=2\n        )\n        self.wait(1)\n\n        # Explain rotation\n        rotation_text = Text(\"This matrix rotates vectors by 90° counterclockwise\", font_size=24)\n        rotation_text.next_to(multiplication, DOWN, buff=0.5)\n        self.play(Write(rotation_text))\n        self.wait(1)\n\n        # Show basis vectors\n        i_hat = Vector([1, 0], color=GREEN)\n        j_hat = Vector([0, 1], color=PURPLE)\n        basis_labels = VGroup(\n            MathTex(r\"\\hat{i}\").next_to(i_hat.get_end(), RIGHT),\n            MathTex(r\"\\hat{j}\").next_to(j_hat.get_end(), UP)\n        )\n        self.play(GrowArrow(i_hat), GrowArrow(j_hat), Write(basis_labels))\n        self.wait(1)\n\n        # Transform basis vectors\n        self.play(\n            i_hat.animate.apply_function(matrix_transform),\n            j_hat.animate.apply_function(matrix_transform),\n            basis_labels[0].animate.next_to(Vector([0, 1]).get_end(), UP),\n            basis_labels[1].animate.next_to(Vector([-1, 0]).get_end(), LEFT),\n            run_time=2\n        )\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\n            \"Matrices transform vectors by transforming the basis vectors\",\n            font_size=32\n        ).next_to(rotation_text, DOWN, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(2)`,

    `def construct(self):\n        # Title\n        title = Text(\"Word Embeddings\", font_size=42)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Explanation text\n        explanation = Text(\n            \"Word embeddings represent words as vectors in a high-dimensional space\",\n            font_size=24\n        ).next_to(title, DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Create a 2D coordinate system (representing a simplified embedding space)\n        plane = NumberPlane(\n            x_range=[-5, 5],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE}\n        )\n        self.play(Create(plane))\n        self.wait(1)\n\n        # Define some example word vectors (using only x and y coordinates)\n        words = {\n            \"king\": np.array([3, 2]),\n            \"queen\": np.array([3, -2]),\n            \"man\": np.array([2, 1]),\n            \"woman\": np.array([2, -1]),\n            \"royal\": np.array([1, 0])\n        }\n\n        # Create dots and labels for each word\n        word_dots = VGroup()\n        word_labels = VGroup()\n        for word, vector in words.items():\n            dot = Dot(point=plane.c2p(*vector), color=YELLOW)\n            label = Text(word, font_size=24).next_to(dot, UP+RIGHT)\n            word_dots.add(dot)\n            word_labels.add(label)\n\n        self.play(Create(word_dots), Write(word_labels))\n        self.wait(2)\n\n        # Highlight relationships\n        self.play(\n            word_dots[0].animate.set_color(RED),  # king\n            word_dots[1].animate.set_color(RED),  # queen\n            word_dots[4].animate.set_color(GREEN)  # royal\n        )\n        relationship = Text(\"Related words are closer in the embedding space\", font_size=24).to_edge(DOWN)\n        self.play(Write(relationship))\n        self.wait(2)\n\n        # Show vector arithmetic\n        vector_math = MathTex(r\"\\text{king} - \\text{man} + \\text{woman} \\approx \\text{queen}\")\n        vector_math.to_edge(LEFT)\n        self.play(Write(vector_math))\n        self.wait(2)\n\n        # Animate vector arithmetic\n        arrow1 = Arrow(start=plane.c2p(*words[\"king\"]), end=plane.c2p(*words[\"man\"]), color=ORANGE)\n        arrow2 = Arrow(start=plane.c2p(*words[\"man\"]), end=plane.c2p(*words[\"woman\"]), color=ORANGE)\n        arrow3 = Arrow(start=plane.c2p(*words[\"woman\"]), end=plane.c2p(*words[\"queen\"]), color=ORANGE)\n\n        self.play(Create(arrow1), Create(arrow2), Create(arrow3), run_time=2)\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\n            \"Word embeddings capture semantic relationships between words\",\n            font_size=32\n        ).next_to(relationship, UP)\n        self.play(Write(conclusion))\n        self.wait(2)`,

    `def construct(self):\n        # Title\n        title = Text(\"Bubble Sort\", font_size=36).to_edge(UP)\n        self.add(title)\n\n        # Create initial array\n        array = [5, 2, 8, 12, 1, 6]\n        \n        # Create rectangles to represent array elements\n        rects = VGroup(*[\n            Rectangle(height=value/3, width=0.8, fill_opacity=0.8, fill_color=BLUE, color=WHITE)\n            for value in array\n        ]).arrange(RIGHT, buff=0.2).move_to(ORIGIN)\n\n        # Add labels to rectangles\n        labels = VGroup(*[\n            Text(str(value), font_size=24).move_to(rect)\n            for value, rect in zip(array, rects)\n        ])\n\n        self.add(rects, labels)\n        self.wait(0.5)\n\n        # Bubble sort animation\n        for i in range(len(array) - 1):\n            for j in range(len(array) - i - 1):\n                # Highlight current pair\n                self.play(\n                    rects[j].animate.set_fill(YELLOW),\n                    rects[j+1].animate.set_fill(YELLOW),\n                    run_time=0.3\n                )\n                \n                if array[j] > array[j+1]:\n                    # Swap elements\n                    array[j], array[j+1] = array[j+1], array[j]\n                    \n                    # Animate swap\n                    self.play(\n                        rects[j].animate.move_to(rects[j+1].get_center()),\n                        rects[j+1].animate.move_to(rects[j].get_center()),\n                        labels[j].animate.move_to(rects[j+1].get_center()),\n                        labels[j+1].animate.move_to(rects[j].get_center()),\n                        run_time=0.3\n                    )\n                    \n                    # Update rects and labels\n                    rects[j], rects[j+1] = rects[j+1], rects[j]\n                    labels[j], labels[j+1] = labels[j+1], labels[j]\n                \n                # Reset color\n                self.play(\n                    rects[j].animate.set_fill(BLUE),\n                    rects[j+1].animate.set_fill(BLUE),\n                    run_time=0.3\n                )\n            \n            # Set color of sorted element\n            self.play(rects[-i-1].animate.set_fill(GREEN), run_time=0.3)\n\n        # Show sorted array\n        sorted_text = Text(\"Sorted\", font_size=36).next_to(rects, DOWN)\n        self.play(Write(sorted_text))\n        self.wait(1)`,

    `def construct(self):\n        # Title\n        title = Text(\"Sierpinski Triangle Fractal\", font_size=42)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Function to create a triangle\n        def create_triangle(points, color=WHITE):\n            return Polygon(*points, color=color, fill_opacity=0.5)\n\n        # Function to generate Sierpinski Triangle points\n        def sierpinski_points(points, depth):\n            if depth == 0:\n                return [points]\n            else:\n                p1, p2, p3 = points\n                p12 = (p1 + p2) / 2\n                p23 = (p2 + p3) / 2\n                p31 = (p3 + p1) / 2\n                return (sierpinski_points([p1, p12, p31], depth - 1) +\n                        sierpinski_points([p12, p2, p23], depth - 1) +\n                        sierpinski_points([p31, p23, p3], depth - 1))\n\n        # Initial triangle\n        points = np.array([[-3, -2, 0], [3, -2, 0], [0, 2*np.sqrt(3)-2, 0]])\n        initial_triangle = create_triangle(points)\n        self.play(Create(initial_triangle))\n        self.wait(1)\n\n        # Generate and display Sierpinski Triangle\n        max_depth = 5\n        for depth in range(1, max_depth + 1):\n            new_triangles = VGroup(*[create_triangle(p, color=BLUE) for p in sierpinski_points(points, depth)])\n            self.play(Transform(initial_triangle, new_triangles))\n            self.wait(1)\n\n        # Show fractal properties\n        properties = VGroup(\n            Text(\"Fractal Properties:\", font_size=36),\n            Text(\"• Self-similarity\", font_size=24),\n            Text(\"• Infinite complexity\", font_size=24),\n            Text(\"• Fractional dimension\", font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT).to_edge(LEFT)\n        self.play(Write(properties))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\n            \"Fractals exhibit infinite detail\\nand self-similarity at all scales\",\n            font_size=32\n        ).next_to(properties, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)`

]

export function getCodeForTopic(topic: string): string | undefined {
    const index = topics.findIndex(t => t === topic);
    if (index !== -1) {
        return codes[index];
    }
    return undefined;
}
