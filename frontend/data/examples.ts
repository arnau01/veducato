export const topics = [
    "Sin Curve and Unit Circle",
    // "Pythagorean Theorem",
    "Integral Area Under Curve",
    // "Vector Matrices",
    "Basic Neural Network",
    "Network Effects",
    "Complex Numbers",
    "Elliptic Curves",
    "Basic Trigonometry",
    // "Speed, Velocity and Acceleration",
    // "Word Embeddings",
    "Probability Distributions",
    // "Bubble Sort",
    // "Sierpinski Triangle Fractal"
]

export const codes = [
    `def construct(self):\n        # Create the coordinate system\n        axes = Axes(\n            x_range=[0, 4*PI, PI],\n            y_range=[-1.5, 1.5, 0.5],\n            x_length=12,\n            y_length=6,\n            axis_config={\"color\": BLUE},\n            x_axis_config={\"numbers_to_include\": []},  # Remove default numbers\n            y_axis_config={\"numbers_to_include\": [-1, 1]},\n            tips=False\n        )\n        axes_labels = axes.get_axis_labels(x_label=\"x\", y_label=\"y\")\n\n        # Create the unit circle\n        circle = Circle(radius=1, color=WHITE)\n        circle.move_to(axes.c2p(0, 0))\n\n        # Create the angle\n        angle = ValueTracker(0)\n        line = always_redraw(lambda: Line(circle.get_center(), circle.point_at_angle(angle.get_value()), color=YELLOW))\n        \n        # Create the sine curve\n        sine_curve = always_redraw(\n            lambda: axes.plot(\n                lambda x: np.sin(x),\n                x_range=[0, angle.get_value()],\n                color=RED\n            )\n        )\n\n        # Create the dot on the circle and its projection\n        moving_dot = always_redraw(lambda: Dot(circle.point_at_angle(angle.get_value()), color=RED))\n        h_line = always_redraw(lambda: DashedLine(\n            moving_dot.get_center(),\n            axes.c2p(angle.get_value(), np.sin(angle.get_value())),\n            color=GRAY\n        ))\n        v_line = always_redraw(lambda: DashedLine(\n            axes.c2p(angle.get_value(), 0),\n            axes.c2p(angle.get_value(), np.sin(angle.get_value())),\n            color=GRAY\n        ))\n        sine_dot = always_redraw(lambda: Dot(\n            axes.c2p(angle.get_value(), np.sin(angle.get_value())),\n            color=RED\n        ))\n\n        # Labels\n        sine_label = MathTex(r\"\\sin(x)\").next_to(axes, UP).set_color(RED)\n        pi_labels = VGroup(*[\n            MathTex(f\"{i}\\pi\").next_to(axes.c2p(i*PI, 0), DOWN)\n            for i in range(1, 5)\n        ])\n\n        # Animations\n        self.play(Create(axes), Write(axes_labels))\n        self.play(Create(circle))\n        self.play(Create(line), Create(moving_dot))\n        self.play(Write(sine_label), Create(h_line), Create(v_line), Create(sine_dot))\n        self.play(Create(sine_curve))\n        self.play(Write(pi_labels))\n\n        # Animate the sine curve\n        self.play(angle.animate.set_value(4*PI), run_time=12, rate_func=linear)\n        self.wait()\n\n        # Highlight key points\n        highlight_points = [\n            (0, \"y = 0\"),\n            (PI/2, \"y = 1\"),\n            (PI, \"y = 0\"),\n            (3*PI/2, \"y = -1\"),\n        \n        ]\n\n        for x, label_text in highlight_points:\n            point = axes.c2p(x, np.sin(x))\n            dot = Dot(point, color=YELLOW)\n            label = Text(label_text, font_size=24).next_to(dot, UP)\n            self.play(Create(dot), Write(label))\n            self.wait(0.5)\n            self.play(FadeOut(dot), FadeOut(label))\n\n        self.wait(2)`, `def construct(self):\n        # Title\n        title = Text(\"Integral: Area Under the Curve\", font_size=42)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Create axes\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 3],\n            axis_config={\"color\": BLUE},\n            x_length=6,\n            y_length=4\n        ).add_coordinates()\n        axes_labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Create graph\n        def func(x):\n            return 0.1 * (x - 1) * (x - 3) * (x - 4) + 2\n\n        graph = axes.plot(func, color=WHITE)\n        graph_label = MathTex(\"f(x)\").next_to(graph.point_from_proportion(0.8), UP)\n\n        # Display axes and graph\n        self.play(Create(axes), Create(axes_labels))\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Integral formula\n        integral = MathTex(r\"\\int_a^b f(x) dx\")\n        integral_text = Text(\"Area under the curve\", font_size=24)\n        integral_group = VGroup(integral, integral_text).arrange(DOWN).to_edge(RIGHT)\n        self.play(Write(integral_group))\n        self.wait(1)\n\n        # Show Riemann sum\n        rectangles = axes.get_riemann_rectangles(\n            graph,\n            x_range=[1, 4],\n            dx=0.5,\n            stroke_width=0.1,\n            stroke_color=WHITE\n        )\n        self.play(Create(rectangles))\n        self.wait(1)\n\n        # Refine Riemann sum\n        for dx in [0.25, 0.1]:\n            new_rectangles = axes.get_riemann_rectangles(\n                graph,\n                x_range=[1, 4],\n                dx=dx,\n                stroke_width=0.1,\n                stroke_color=WHITE\n            )\n            self.play(Transform(rectangles, new_rectangles))\n            self.wait(1)\n\n        # Show area\n        area = axes.get_area(graph, x_range=[1, 4], color=YELLOW, opacity=0.3)\n        self.play(FadeOut(rectangles), FadeIn(area))\n        self.wait(1)\n\n        # Highlight bounds\n        x_1 = axes.get_vertical_line(axes.c2p(1, 0), color=GREEN)\n        x_4 = axes.get_vertical_line(axes.c2p(4, 0), color=RED)\n        bound_labels = VGroup(\n            MathTex(\"a\").next_to(x_1, DOWN),\n            MathTex(\"b\").next_to(x_4, DOWN)\n        )\n        self.play(Create(x_1), Create(x_4), Write(bound_labels))\n        self.wait(1)\n\n        # Final formula\n        final_integral = MathTex(r\"\\int_1^4 f(x) dx = \\text{Area}\")\n        final_integral.next_to(area, DOWN, buff=0.5)\n        self.play(Write(final_integral))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\n            \"The definite integral represents\\nthe area under the curve\\nbetween two points\",\n            font_size=32,\n            t2c={\"area\": YELLOW, \"two points\": GREEN}\n        ).next_to(final_integral, DOWN, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(2)`
    
    
    ,`def construct(self):\n        # Title\n        title = Text(\"Basic Neural Network\", font_size=42)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Create layers\n        input_layer = VGroup(*[Circle(radius=0.2, color=BLUE) for _ in range(4)]).arrange(DOWN, buff=0.5)\n        hidden_layer = VGroup(*[Circle(radius=0.2, color=GREEN) for _ in range(5)]).arrange(DOWN, buff=0.5)\n        output_layer = VGroup(*[Circle(radius=0.2, color=RED) for _ in range(3)]).arrange(DOWN, buff=0.5)\n\n        # Arrange layers\n        layers = VGroup(input_layer, hidden_layer, output_layer).arrange(RIGHT, buff=2)\n        self.play(Create(layers))\n        self.wait(1)\n\n        # Add layer labels\n        labels = VGroup(\n            Text(\"Input Layer\").next_to(input_layer, DOWN),\n            Text(\"Hidden Layer\").next_to(hidden_layer, DOWN),\n            Text(\"Output Layer\").next_to(output_layer, DOWN)\n        )\n        self.play(Write(labels))\n        self.wait(1)\n\n        # Create connections\n        connections = VGroup()\n        for i, layer1 in enumerate(layers[:-1]):\n            layer2 = layers[i+1]\n            for neuron1 in layer1:\n                for neuron2 in layer2:\n                    connection = Line(neuron1.get_center(), neuron2.get_center(), stroke_opacity=0.3)\n                    connections.add(connection)\n\n        self.play(Create(connections), run_time=2)\n        self.wait(1)\n\n        # Highlight data flow\n        def highlight_path():\n            path = VGroup()\n            for i in range(len(layers) - 1):\n                start_neuron = random.choice(layers[i])\n                end_neuron = random.choice(layers[i+1])\n                path.add(Line(start_neuron.get_center(), end_neuron.get_center(), stroke_width=4, color=YELLOW))\n            return path\n\n        for _ in range(3):  # Show 3 random paths\n            path = highlight_path()\n            self.play(Create(path), run_time=0.5)\n            self.wait(0.5)\n            self.play(FadeOut(path), run_time=0.5)\n\n        # Add explanation\n        explanation = VGroup(\n            Text(\"• Each circle represents a neuron\", font_size=24),\n            Text(\"• Lines represent connections between neurons\", font_size=24),\n            Text(\"• Information flows from input to output\", font_size=24),\n            Text(\"• The hidden layer allows for complex pattern recognition\", font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT).next_to(layers, DOWN, buff=0.5)\n\n        self.play(Write(explanation), run_time=2)\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\n            \"Neural networks can learn to recognize patterns\\nand make decisions based on input data\",\n            font_size=32\n        ).next_to(explanation, DOWN, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(2)`,`def construct(self):\n        # Title\n        title = Text(\"Network Effects\", font_size=42)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Explanation text\n        explanation = Text(\n            \"The value of a network increases as more users join\",\n            font_size=24\n        ).next_to(title, DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Create initial network\n        def create_network(num_nodes):\n            nodes = VGroup(*[Dot(radius=0.1, color=BLUE) for _ in range(num_nodes)])\n            nodes.arrange_in_grid(rows=int(num_nodes**0.5), buff=1)\n            return nodes\n\n        initial_nodes = create_network(9)\n        self.play(Create(initial_nodes))\n        self.wait(1)\n\n        # Add connections\n        def add_connections(nodes, probability=0.3):\n            connections = VGroup()\n            for i, node1 in enumerate(nodes):\n                for j, node2 in enumerate(nodes[i+1:], start=i+1):\n                    if random.random() < probability:\n                        line = Line(node1.get_center(), node2.get_center(), stroke_opacity=0.5)\n                        connections.add(line)\n            return connections\n\n        initial_connections = add_connections(initial_nodes)\n        self.play(Create(initial_connections))\n        self.wait(1)\n\n        # Show value\n        value_text = Text(\"Network Value\", font_size=36).to_edge(LEFT)\n        value = DecimalNumber(\n            9,  # Initial value\n            num_decimal_places=0,\n            font_size=36\n        ).next_to(value_text, RIGHT)\n        self.play(Write(value_text), Write(value))\n        self.wait(1)\n\n        # Function to update network\n        def update_network(num_new_nodes):\n            new_nodes = create_network(num_new_nodes)\n            new_nodes.move_to(initial_nodes.get_center())\n            scale_factor = initial_nodes.width / new_nodes.width\n            new_nodes.scale(scale_factor)\n            \n            all_nodes = VGroup(*initial_nodes, *new_nodes)\n            new_connections = add_connections(all_nodes, probability=0.1)\n            \n            new_value = len(all_nodes) ** 2  # Metcalfe's Law\n            \n            return new_nodes, new_connections, new_value\n\n        # Add users and show increased value\n        for _ in range(3):\n            new_nodes, new_connections, new_value = update_network(9)\n            \n            self.play(\n                Create(new_nodes),\n                Create(new_connections),\n                ChangeDecimalToValue(value, new_value)\n            )\n            self.wait(1)\n            \n            initial_nodes.add(*new_nodes)\n            initial_connections.add(*new_connections)\n\n        # Highlight network effect\n        self.play(Indicate(initial_nodes, color=YELLOW), Indicate(initial_connections, color=YELLOW))\n        self.wait(1)\n\n        # Metcalfe's Law\n        metcalfe = Text(\"Metcalfe's Law: Value ∝ n²\", font_size=36).to_edge(DOWN)\n        self.play(Write(metcalfe))\n        self.wait(1)\n\n        # Examples\n        examples = VGroup(\n            Text(\"• Social networks\", font_size=24),\n            Text(\"• Communication platforms\", font_size=24),\n            Text(\"• Operating systems\", font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT).next_to(metcalfe, UP)\n        self.play(Write(examples))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\n            \"Network effects create a positive feedback loop,\\ndriving rapid growth and market dominance\",\n            font_size=32\n        ).next_to(examples, UP)\n        self.play(Write(conclusion))\n        self.wait(2)`,`def construct(self):\n        # Title\n        title = Text(\"Complex Numbers\", font_size=48)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Basic definition\n        definition = MathTex(\"z = a + bi\", \", where \", \"i^2 = -1\")\n        self.play(Write(definition))\n        self.wait(1)\n        self.play(definition.animate.to_edge(UP).shift(DOWN))\n\n        # Create complex plane\n        plane = ComplexPlane().scale(2)\n        self.play(Create(plane))\n        self.wait(1)\n\n        # Show a complex number\n        z = 3 + 2j\n        dot_z = Dot(plane.n2p(z), color=RED)\n        label_z = MathTex(\"z = 3 + 2i\").next_to(dot_z, UR, buff=0.1)\n        arrow_z = Arrow(plane.n2p(0), plane.n2p(z), buff=0, color=RED)\n        self.play(Create(dot_z), Write(label_z), Create(arrow_z))\n        self.wait(1)\n\n        # Show real and imaginary parts\n        real_line = Line(plane.n2p(0), plane.n2p(z.real), color=GREEN)\n        imag_line = Line(plane.n2p(z.real), plane.n2p(z), color=BLUE)\n        real_label = MathTex(\"Re(z) = 3\").next_to(real_line, DOWN, buff=0.1)\n        imag_label = MathTex(\"Im(z) = 2\").next_to(imag_line, RIGHT, buff=0.1)\n        self.play(Create(real_line), Create(imag_line), Write(real_label), Write(imag_label))\n        self.wait(1)\n\n        # Polar form\n        angle = np.angle(z)\n        radius = abs(z)\n        arc = Arc(radius=0.5, angle=angle, color=YELLOW)\n        radius_line = Line(plane.n2p(0), plane.n2p(z), color=YELLOW)\n        angle_label = MathTex(r\"\\theta\").next_to(arc, RIGHT, buff=0.1)\n        radius_label = MathTex(r\"|z| = \\sqrt{a^2 + b^2}\").next_to(radius_line, UR, buff=0.1)\n        self.play(Create(arc), Create(radius_line), Write(angle_label), Write(radius_label))\n        self.wait(1)\n\n        # Polar form equation\n        polar_form = MathTex(\"z = |z|(\\\\cos\\\\theta + i\\\\sin\\\\theta) = |z|e^{i\\\\theta}\")\n        polar_form.to_edge(DOWN)\n        self.play(Write(polar_form))\n        self.wait(1)\n\n        # Addition\n        w = 1 - 1j\n        dot_w = Dot(plane.n2p(w), color=BLUE)\n        label_w = MathTex(\"w = 1 - i\").next_to(dot_w, UL, buff=0.1)\n        arrow_w = Arrow(plane.n2p(0), plane.n2p(w), buff=0, color=BLUE)\n        self.play(Create(dot_w), Write(label_w), Create(arrow_w))\n        self.wait(1)\n\n        sum_z_w = z + w\n        dot_sum = Dot(plane.n2p(sum_z_w), color=PURPLE)\n        label_sum = MathTex(\"z + w\").next_to(dot_sum, UR, buff=0.1)\n        arrow_sum = Arrow(plane.n2p(0), plane.n2p(sum_z_w), buff=0, color=PURPLE)\n        self.play(Create(dot_sum), Write(label_sum), Create(arrow_sum))\n        self.wait(1)\n\n        # Multiplication\n        product = z * w\n        dot_product = Dot(plane.n2p(product), color=ORANGE)\n        label_product = MathTex(\"z \\\\times w\").next_to(dot_product, UR, buff=0.1)\n        arrow_product = Arrow(plane.n2p(0), plane.n2p(product), buff=0, color=ORANGE)\n        self.play(Create(dot_product), Write(label_product), Create(arrow_product))\n        self.wait(1)\n\n        # Explanation of multiplication\n        mult_explanation = Text(\"Multiplication: rotate and scale\", font_size=24).to_edge(DOWN)\n        self.play(Write(mult_explanation))\n        self.wait(1)\n\n        # Applications\n        applications = VGroup(\n            Text(\"Applications:\", font_size=28),\n            Text(\"• Electrical Engineering\", font_size=24),\n            Text(\"• Quantum Mechanics\", font_size=24),\n            Text(\"• Computer Graphics\", font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT).to_edge(RIGHT)\n        self.play(Write(applications))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\n            \"Complex numbers extend real numbers\\n\"\n            \"and have powerful geometric interpretations.\",\n            font_size=24\n        ).next_to(applications, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)`,`def construct(self):\n            # Title\n            title = Text(\"Elliptic Curves\", font_size=48).to_edge(UP)\n            self.play(Write(title))\n\n            # Create axes\n            axes = Axes(\n                x_range=[-3, 3, 1],\n                y_range=[-3, 3, 1],\n                axis_config={\"color\": BLUE},\n                x_length=6,\n                y_length=6\n            ).add_coordinates()\n            self.play(Create(axes))\n\n            # Define and plot elliptic curve\n            a, b = -1, 1  # Example parameters\n            curve = VGroup(\n                ParametricFunction(\n                    lambda t: axes.c2p(t, np.sqrt(max(0, t**3 - t + 1))),\n                    t_range=[-1.5, 3],\n                    color=RED,\n                ),\n                ParametricFunction(\n                    lambda t: axes.c2p(t, -np.sqrt(max(0, t**3 - t + 1))),\n                    t_range=[-1.5, 3],\n                    color=RED,\n                )\n            )\n            self.play(Create(curve))\n\n            # Show equation\n            equation = MathTex(\"y^2 = x^3 + ax + b\").next_to(axes, UP).shift(LEFT * 2)\n            params = MathTex(\"a = -1, b = 1\").next_to(equation, DOWN)\n            self.play(Write(equation), Write(params))\n\n            # Demonstrate point addition\n            P = Dot(axes.c2p(-1, 1), color=GREEN)\n            Q = Dot(axes.c2p(0, 1), color=BLUE)\n            P_label = Text(\"P\", font_size=24).next_to(P, UP)\n            Q_label = Text(\"Q\", font_size=24).next_to(Q, UP)\n            self.play(Create(P), Create(Q), Write(P_label), Write(Q_label))\n\n            # Line through P and Q\n            line = Line(P.get_center(), Q.get_center())\n            line.scale(5)  # Scale the line instead of using scale_about_point\n            self.play(Create(line))\n\n            # Find third intersection point\n            R = Dot(axes.c2p(2, -3), color=YELLOW)\n            R_label = Text(\"R\", font_size=24).next_to(R, DOWN)\n            self.play(Create(R), Write(R_label))\n\n            # Reflect R across x-axis to get P+Q\n            PplusQ = Dot(axes.c2p(2, 3), color=PURPLE)\n            PplusQ_label = Text(\"P+Q\", font_size=24).next_to(PplusQ, UP)\n            dashed_line = DashedLine(R.get_center(), PplusQ.get_center())\n            self.play(Create(dashed_line), Create(PplusQ), Write(PplusQ_label))\n\n            # Explanation of point addition\n            addition_explanation = Text(\n                \"Point addition: P + Q = -(P * Q * curve)\",\n                font_size=24\n            ).to_edge(DOWN)\n            self.play(Write(addition_explanation))\n\n            # Applications\n            applications = VGroup(\n                Text(\"Applications:\", font_size=28),\n                Text(\"• Cryptography\", font_size=24),\n                Text(\"• Number Theory\", font_size=24)\n            ).arrange(DOWN, aligned_edge=LEFT).to_edge(RIGHT)\n            self.play(Write(applications))\n\n            # Conclusion\n            conclusion = Text(\n                \"Elliptic curves have a rich structure\\n\"\n                \"with important applications.\",\n                font_size=24\n            ).next_to(applications, DOWN)\n            self.play(Write(conclusion))\n            self.wait(2)`,`def construct(self):\n        # Title\n        title = Text(\"Basic Trigonometry\", font_size=48)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Create unit circle\n        circle = Circle(radius=2, color=BLUE)\n        self.play(Create(circle))\n        self.wait(1)\n\n        # Add axes\n        axes = Axes(\n            x_range=[-2.5, 2.5],\n            y_range=[-2.5, 2.5],\n            axis_config={\"color\": GRAY},\n            x_length=5,\n            y_length=5\n        )\n        self.play(Create(axes))\n        self.wait(1)\n\n        # Add labels\n        x_label = axes.get_x_axis_label(\"x\")\n        y_label = axes.get_y_axis_label(\"y\")\n        self.play(Write(x_label), Write(y_label))\n        self.wait(1)\n\n        # Create angle\n        angle = ValueTracker(0)\n        line = always_redraw(lambda: Line(ORIGIN, axes.c2p(np.cos(angle.get_value()), np.sin(angle.get_value())), color=YELLOW))\n        angle_arc = always_redraw(lambda: Arc(radius=0.5, angle=angle.get_value(), color=GREEN))\n        angle_label = always_redraw(lambda: MathTex(r\"\\theta\").next_to(angle_arc, RIGHT, buff=0.1))\n        \n        self.play(Create(line), Create(angle_arc), Write(angle_label))\n        self.wait(1)\n\n        # Show sine and cosine\n        sine_line = always_redraw(lambda: Line(\n            axes.c2p(np.cos(angle.get_value()), 0),\n            axes.c2p(np.cos(angle.get_value()), np.sin(angle.get_value())),\n            color=RED\n        ))\n        cosine_line = always_redraw(lambda: Line(\n            ORIGIN,\n            axes.c2p(np.cos(angle.get_value()), 0),\n            color=GREEN\n        ))\n        \n        sine_label = always_redraw(lambda: MathTex(r\"\\sin(\\theta)\").next_to(sine_line, RIGHT, buff=0.1))\n        cosine_label = always_redraw(lambda: MathTex(r\"\\cos(\\theta)\").next_to(cosine_line, DOWN, buff=0.1))\n        \n        self.play(Create(sine_line), Create(cosine_line), Write(sine_label), Write(cosine_label))\n        self.wait(1)\n\n        # Animate the angle\n        self.play(angle.animate.set_value(PI/2), run_time=2)\n        self.wait(1)\n        self.play(angle.animate.set_value(PI), run_time=2)\n        self.wait(1)\n        self.play(angle.animate.set_value(3*PI/2), run_time=2)\n        self.wait(1)\n        self.play(angle.animate.set_value(2*PI), run_time=2)\n        self.wait(1)\n\n        # Show right triangle\n        triangle = always_redraw(lambda: Polygon(\n            ORIGIN,\n            axes.c2p(np.cos(angle.get_value()), 0),\n            axes.c2p(np.cos(angle.get_value()), np.sin(angle.get_value())),\n            color=WHITE\n        ))\n        self.play(Create(triangle))\n        self.wait(1)\n\n        # Add formulas\n        formulas = VGroup(\n            MathTex(r\"\\sin(\\theta) = \\frac{\\text{opposite}}{\\text{hypotenuse}}\"),\n            MathTex(r\"\\cos(\\theta) = \\frac{\\text{adjacent}}{\\text{hypotenuse}}\"),\n            MathTex(r\"\\tan(\\theta) = \\frac{\\text{opposite}}{\\text{adjacent}} = \\frac{\\sin(\\theta)}{\\cos(\\theta)}\")\n        ).arrange(DOWN, aligned_edge=LEFT).to_edge(RIGHT)\n        self.play(Write(formulas))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\n            \"Trigonometric functions relate\\nangles to ratios of sides\\nin right triangles\",\n            font_size=24\n        ).next_to(formulas, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)`,`def construct(self):\n        title = Text(\"Probability Distributions\", font_size=48)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 0.5, 0.1],\n            axis_config={\"color\": BLUE},\n            x_length=10,\n            y_length=5\n        ).shift(DOWN)\n        \n        x_label = axes.get_x_axis_label(\"x\")\n        y_label = axes.get_y_axis_label(\"P(x)\")\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        self.wait(1)\n\n        def normal_pdf(x):\n            return stats.norm.pdf(x, loc=0, scale=1)\n\n        normal_graph = axes.plot(normal_pdf, color=RED)\n        normal_label = Text(\"Normal Distribution\", font_size=24, color=RED).next_to(normal_graph, UP)\n        \n        self.play(Create(normal_graph), Write(normal_label))\n        self.wait(1)\n\n        def uniform_pdf(x):\n            return stats.uniform.pdf(x, loc=-2, scale=4)\n\n        uniform_graph = axes.plot(uniform_pdf, color=GREEN)\n        uniform_label = Text(\"Uniform Distribution\", font_size=24, color=GREEN).next_to(uniform_graph, DOWN)\n        \n        self.play(Create(uniform_graph), Write(uniform_label))\n        self.wait(1)\n\n        def exponential_pdf(x):\n            return stats.expon.pdf(x, loc=0, scale=1)\n\n        exponential_graph = axes.plot(exponential_pdf, color=YELLOW)\n        exponential_label = Text(\"Exponential Distribution\", font_size=24, color=YELLOW).next_to(exponential_graph, RIGHT)\n        \n        self.play(Create(exponential_graph), Write(exponential_label))\n        self.wait(2)`

]

export function getCodeForTopic(topic: string): string | undefined {
    const index = topics.findIndex(t => t === topic);
    if (index !== -1) {
        return codes[index];
    }
    return undefined;
}
